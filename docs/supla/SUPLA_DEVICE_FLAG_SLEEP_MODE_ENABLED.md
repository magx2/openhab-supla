# Server Handling of `SUPLA_DEVICE_FLAG_SLEEP_MODE_ENABLED`

- **Flag definition** – The device bitmask reserves `0x0020` for sleep-mode support, declared in `supla-core/supla-common/proto.h:603-610`. Any device that sets this bit during registration is treated as a sleeper by server-side code.

- **Connection lifecycle hooks** – `supla_device::is_sleeping_object` and `supla_device::can_reconnect` interpret the flag to mark a connection as “sleeping” while cached channel values remain valid and to disable automatic reconnection attempts (`supla-core/supla-server/src/device/device.cpp:79-90`). The generic connection loop checks `is_sleeping_object()` before timing out; instead of terminating aggressively it logs “Sleeping device” and later waits for the advertised wake-up duration before closing the socket (`supla-core/supla-server/src/conn/connection.cpp:343-419`). This is the central server behavior change: sleepers keep their session alive only long enough to deliver cached data, after which the server quietly idles until the next wake cycle.

- **Registration responses** – When a registering device presents the flag, the abstract register handler inspects the last cal/cfg command that matters for sleepers and swaps the standard `SUPLA_RESULTCODE_TRUE` for `*_REQUESTED` responses (cfg mode, restart, or identify) so the device can honor pending maintenance while it is awake (`supla-core/supla-server/src/device/call_handler/abstract_register_device.cpp:543-557`). Normal devices never receive those specialized codes.

- **Channel state servicing** – Clients asking for channel state on a sleeping device are served synchronously from cached data when available. If the flag is present and `get_channel_state` succeeds immediately, the server responds without pinging the hardware; otherwise it falls back to the asynchronous request flow (`supla-core/supla-server/src/client/call_handler/get_channel_state.cpp:40-57`).

- **Pending cal/cfg commands** – Configuration commands issued while the device sleeps (entering cfg mode, restart, identify) are stored in `device->last_calcfg_command_importatnt_for_sleepers` whenever the server invokes the matching SRPC call (`supla-core/supla-server/src/device/device.cpp:140-220`). Those commands map to special result codes defined in the protocol (`SUPLA_RESULTCODE_CFG_MODE_REQUESTED`, `SUPLA_RESULTCODE_RESTART_REQUESTED`, `SUPLA_RESULTCODE_IDENTIFY_REQUESTED`; see `supla-core/supla-common/proto.h:350-361`). During the next registration the handler inspects the stored command and swaps the normal success code for the appropriate `*_REQUESTED` response so the firmware can perform the pending action before going back to sleep (`supla-core/supla-server/src/device/call_handler/abstract_register_device.cpp:545-557`). Once the device reports success through `DEVICE_CALCFG_RESULT`, the server clears the remembered command (`supla-core/supla-server/src/device/call_handler/device_calcfg_result.cpp:1-74`). This cycle lets administrators queue maintenance for sleepers without waiting for a live connection.

- **Offline window** – Every channel carries a validity horizon (`validity_time_sec`) that is stored when the device last reported a value; the constructor stamps `value_valid_to` with that TTL and `supla_device_channels::get_value_validity_time_left_msec` exposes the longest remaining time across all channels (`supla-core/supla-server/src/device/devicechannel.cpp:52-101`, `supla-core/supla-server/src/device/devicechannels.cpp:1587-1596`). The connection loop uses that figure to decide how long a flagged device may stay silent before the socket is closed (`supla-core/supla-server/src/conn/connection.cpp:374-419`). In practice the server will keep the connection parked—and clients reading cached state—until that validity timer expires, at which point the device must wake up and refresh values.

- **Reconnect semantics** – When a previously registered sleeper reconnects, it still goes through the register-device flow. The handler loads the persisted device row, ensures the stored location matches the incoming request, reuses or updates channels, and synchronizes flags such as `DEVICE_LOCKED`; only if all invariants hold does it commit the transaction and emit a success/result code tailored to sleepers (`supla-core/supla-server/src/device/call_handler/abstract_register_device.cpp:320-569`). This means the server expects a reconnecting device to present the same GUID/location/auth combo as before, after which it may receive pending cal/cfg commands (cfg mode, restart, identify) in the response before going back to sleep.

Overall, the flag informs the server that (1) the connection should tolerate long inactive windows, (2) pending maintenance commands must be surfaced at registration time, and (3) channel queries should rely on cached snapshots whenever possible.
